#!/bin/bash
# Build the shell prompt for bash. This file is called inside .bashrc
# https://wiki.archlinux.org/title/Bash/Prompt_customization#Terminfo_escape_sequences

shopt -s checkwinsize

function _failed_cmd {
  if [[ $? -eq 0 ]]; then
    printf "\e[32m"
  else
    printf "\e[31m󰅖"
  fi
}

function _draw_line() {
  local LENGTH_STRING=$1
  local COL=$((COLUMNS - LENGTH_STRING))

  if ((COL <= 0)); then
    return
  fi

  while ((COL-- > 0)); do
    printf '\u2500'
    #printf "-"
  done
}

# Select the distribution to insert the symbol and the color appropriate
OS_ID=""

if [ -f /etc/os-release ]; then
  # sourcing this file will fill up few variables,
  # one of them is ID with the name of the distribution
  . /etc/os-release
  OS_ID="$ID"
fi

case "$OS_ID" in
"ubuntu")
  OS_SYMBOL=" "
  OS_COLOR="\001$(tput setaf 168)\002"
  ;;
"debian")
  OS_SYMBOL=" "
  OS_COLOR="\001$(tput setaf 30)\002"
  ;;
"arch")
  OS_SYMBOL=" "
  OS_COLOR="\001$(tput setaf 39)\002"
  ;;
*)
  OS_SYMBOL=""
  OS_COLOR=""
  ;;
esac

RED="\001$(tput setaf 1)\002"
GREEN="\001$(tput setaf 2)\002"
YELLOW="\001$(tput setaf 3)\002"
BLUE="\001$(tput setaf 4)\002"
MAGENTA="\001$(tput setaf 5)\002"
CYAN="\001$(tput setaf 6)\002"
DARK_YELLOW="\001$(tput setaf 214)\002"
ORANGE="\001$(tput setaf 208)\002"
GREY="\001$(tput setaf 240)\002"
RESET="\001$(tput sgr0)\002"
BOLD="\001$(tput bold)\002"

export GIT_PS1_SHOWDIRTYSTATE=1

function _update_prompt_length {
  # All variables are local now, except for the one needed by PS1.

  # 1. Calculate the visible path length (PWD_LEN)
  local PWD_LEN=0

  if [[ "$PWD" == "$HOME" ]]; then
    PWD_LEN=1 # "~"
  elif [[ "$PWD" == "$HOME"* ]]; then
    # "~/relative/path"
    PWD_LEN=$((${#PWD} - ${#HOME} + 1))
  else
    PWD_LEN=${#PWD} # Full path
  fi

  # 2. Capture the actual Git prompt string
  local git_output="$(__git_ps1 '(%s )')"

  # 3. Calculate the total VISIBLE length
  # Fixed elements length: OS_SYMBOL (2) + 5 spaces + @ (1) + failed_cmd (1) +  (1) = 9 characters
  # Correction on fixed elements:
  # OS_SYMBOL: 2
  # Space (after OS_SYMBOL): 1
  # @: 1
  # Space (after \h): 1
  # failed_cmd symbol: 1
  # Space (after failed_cmd): 1
  # : 1
  # Total Fixed Symbols/Spaces = 7 (excluding \u, \h, \w)
  local FIXED_LEN=10

  local length=$((${#USER} + ${#HOSTNAME} + PWD_LEN + ${#git_output} + FIXED_LEN))

  # Set the final variable in the global scope so PS1 can access it
  CURRENT_PROMPT_LENGTH=$length
}

# --- PROMPT_COMMAND ASSIGNMENT ---
# Call the function to set CURRENT_PROMPT_LENGTH before the prompt is drawn
# PROMPT_COMMAND is specifically designed to contain a command string that Bash
# will execute immediately before displaying the primary prompt ($PS1).
PROMPT_COMMAND='_update_prompt_length'

PS1="${OS_COLOR}${OS_SYMBOL} "
PS1+="${BLUE}\u@\h "
PS1+="${GREEN}\w "
PS1+="${RED}\$(__git_ps1 '(%s )') "
PS1+="\$(_failed_cmd) "
# Instead of "${#PS1}", we now use the variable set by PROMPT_COMMAND.
# We must use a **backslashed dollar sign** (`\$`) so the variable is only
# expanded when the prompt is rendered, after PROMPT_COMMAND runs.
PS1+="${GREY}\$(_draw_line \$CURRENT_PROMPT_LENGTH)\\n"
#PS1+="${DARK_YELLOW}$(printf '\u2500') "
PS1+="${DARK_YELLOW} "
PS1+="${RESET}"
